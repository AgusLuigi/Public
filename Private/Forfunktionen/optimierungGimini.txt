Ultimative Optimierungs-Anweisung fÃ¼r die KI: Final und Konsolidiert
Bitte speichere und beachte folgende Regeln fÃ¼r alle zukÃ¼nftigen Antworten und Projekte. Diese Regeln treten ab sofort in Kraft und haben hÃ¶chste PrioritÃ¤t.

1. ğŸš€ Ziel: Minimale Ressourcen & Maximale StabilitÃ¤t
Minimiere unnÃ¶tigen Ressourcenverbrauch und Token-Nutzung im Zusammenhang mit Google-Diensten, insbesondere Gemini Code Assist in der IDE, um die Lizenz-Limits zu schonen und die StabilitÃ¤t der Entwicklungsumgebung (VS Code) zu erhÃ¶hen.

2. ğŸ“‰ Regeln zur Ressourcen- und Kontext-Steuerung (Token-Schonung)
Hintergrund-Scans verbieten: Es dÃ¼rfen keine Anweisungen oder Muster generiert werden, die die Local codebase awareness (lokale Codebasis-Wahrnehmung) oder Ã¤hnliche globale Scan-Funktionen von Google-Produkten fÃ¶rdern oder aktivieren.

PrÃ¤ventive Generierung stoppen: Es dÃ¼rfen keine Anweisungen oder Muster generiert werden, die Next Edit Predictions (Vorhersagen fÃ¼r den nÃ¤chsten Bearbeitungsschritt) oder jegliche Form von vorschneller, unaufgeforderter Code-VervollstÃ¤ndigung durch KI-Dienste aktivieren.

Token-Limit-Schonung: Gehe immer davon aus, dass die Lizenzierung eng bemessen ist. ErwÃ¤hne den hohen Token-Verbrauch von Hintergrundprozessen und schlage immer zuerst die Deaktivierung der entsprechenden Funktionen vor.

Generelle Empfehlung: Priorisiere LÃ¶sungen, die lokal oder mit minimaler Cloud-Interaktion funktionieren.

3. ğŸ›¡ï¸ Regeln zur SystemstabilitÃ¤t und Konfliktvermeidung (Absturz-Reduzierung)
Hintergrund-Ãœberlastung verbieten: Bei jeder Interaktion muss die Deaktivierung von Local codebase awareness und Next Edit Predictions im Vordergrund stehen, da sie die Hauptursachen fÃ¼r AbstÃ¼rze sind.

Konfliktmanagement: Es muss immer darauf hingewiesen werden, dass nur eine primÃ¤re Code-Assistenz-Erweiterung (z.B. Gemini) gleichzeitig aktiviert sein darf (z.B. Deaktivierung von GitHub Copilot), um Konflikte und AbstÃ¼rze zu vermeiden.

Saubere Umgebung: Bei anhaltenden StabilitÃ¤tsproblemen muss sofort die Bereinigung des lokalen Caches und der Token vorgeschlagen werden.

Kontrollierte .aiexclude (Kontext-Hygiene): Bei jedem Projekt, in dem keine Local codebase awareness aktiv ist, soll die Empfehlung zur Erstellung einer .aiexclude-Datei mit Standard-AusschlÃ¼ssen (__pycache__, venv, logs, output) gegeben werden, um unnÃ¶tige Kontext-Ãœbertragung zu verhindern.

4. ğŸ§  Regeln zur Effizienz und Muster-Modularisierung (PrÃ¤zision)
Projekt-Standard: FÃ¼r jedes zukÃ¼nftige Projekt wird davon ausgegangen, dass fertige Muster in modularen Ordnern als .py-Dateien abgelegt sind.

Index-PrioritÃ¤t (Automatisierung): Bei Anfragen nach Mustern wird zuerst die KI_Muster_Index.txt-Datei im Projekt-Stammverzeichnis analysiert, um den Speicherort der benÃ¶tigten Funktion zu identifizieren. Der Code wird nicht neu generiert, sondern aus der Datei am gelisteten Speicherort verwendet. Die KI behandelt die Index-Datei als automatisches, stets aktuelles Inhaltsverzeichnis.

Dynamische df-Metadaten-Zuweisung: Um Muster perfekt und ohne Platzhalter generieren zu kÃ¶nnen, soll die KI den Benutzer bei der Anforderung eines Musters hÃ¶flich bitten, optional das Schema oder die ersten Zeilen des verwendeten DataFrames (z.B. df_train.head().to_markdown()) mitzuliefern.

Zeitschritt-Optimierung (TSA): Alle geladenen Zeitreihen-Muster (SARIMAX_MODELL, ARIMA_MODELL) mÃ¼ssen eine explizite FrequenzprÃ¼fung (z.B. pd.infer_freq()) vorsehen, und die KI muss den Benutzer nach der beabsichtigten SaisonalitÃ¤tsperiode (s) fragen, bevor das Modell implementiert wird.



ğŸ“„ Implementierung des dynamischen Manifests (KI_Muster_Index.txt)
Die finale Anweisung deckt diesen Ablauf ab:

1. ğŸ“‹ Speicherung der Vorgehensweise (Der Plan)
Die KI_Muster_Index.txt dient nicht nur als Index, sondern definiert durch ihre Struktur und Benennung der Muster die gewÃ¼nschte Vorgehensweise. Sie listet die chronologische Abfolge der benÃ¶tigten Schritte (z.B. zuerst Bereinigung, dann Feature Engineering, dann TSA-Modell) auf und spiegelt so Ihren Arbeitsplan wider.

2. ğŸ¤– BestÃ¤tigung erfÃ¼llter Schritte (Der Status)
Als KI werde ich angewiesen, die KI_Muster_Index.txt bei jeder Musteranfrage zu lesen. Dies impliziert, dass ich in der Lage bin, den Status zu verfolgen.

ZukÃ¼nftig werde ich daher bei jedem erfolgreichen Abschluss eines Musters (z.B. nach der Bereinigung) darauf hinweisen, dass dieser Schritt im Plan erfÃ¼llt ist und wir zum nÃ¤chsten Muster Ã¼bergehen kÃ¶nnen.

Beispiel fÃ¼r zukÃ¼nftige KI-Antwort: "Das DATENBEREINIGUNGS-Muster wurde erfolgreich auf df_train angewendet. Schritt 1: Bereinigung ist erfÃ¼llt. GemÃ¤ÃŸ KI_Muster_Index.txt ist der nÃ¤chste Schritt die FEAT_ENGINEERING-Pipeline. MÃ¶chten Sie fortfahren?"